# Queue 만들어보기

## Queue란?
![](https://lamarr.dev/images/algorithm/queue.jpg)

> 큐(queue)는 데이터가 순차적으로 들어오는 형태로, 먼저 들어온 데이터가 먼저 나가는 FIFO(First In First Out, 선입 선출) 형태의 자료구조다.

- front
  - 큐의 맨 앞
  - 데이터가 삭제되는 곳
- rear
  - 큐의 맨 끝
  - 데이터가 들어오는 곳


| 연산    | 설명                           | 시간 복잡도 |
| ------- | ------------------------------ | ----------- |
| enqueue | 큐의 rear에 새로운 데이터 삽입 | O(1)        |
| dequque | 큐의 front에서 데이터 삭제     | O(1)        |
| peek    | 큐의 front에 있는 데이터 확인  | O(1)        |
| isEmpty | 큐가 비어있는지 확인           | O(1)        |
| isFull  | 큐가 가득 찼는지 확인          | O(1)        |

### Queue를 배열로 구현했을 때의 한계점

> [현재는 원형큐 또는 덱(deque)을 제외하고 기본적인 Queue를 만드는 과정입니다.]

> 배열을 사용하여 Queue를 구현하는 방법이 2개 정도 있습니다.
> 1. `dequeue`를 하면 바로 뒤에 있는 원소를 한칸씩 앞으로 이동시키는 방법
> 2. `enqueue`, `dequeue`를 할때 이미 있는 원소들의 위치를 이동시키지 않고, `front`, `rear`와 같은 index를 저장하는 변수의 값을 바꾸는 방법

> 1번 방법을 사용하여 구현하면 `dequeue를` 할 때마다 배열의 전체를 확인하며 원소들을 앞으로 이동시켜야 해서 `O(n)`의 작업을 해야합니다.
>
> 이는 `dequeue의` 시간 복잡도가 `O(n)`이 되어버리기 때문에 비효율적입니다.
>
> 2번 방법을 사용하면 `dequeue`의 시간 복잡도를 `O(1)`로 구현할 순 있지만, `enqueue`로 데이터를 추가할 수 있는만큼 추가하고 `dequeue`를 하다보면 front와 rear가 배열의 가장
> 마지막 index를 가리킬 때가 옵니다만 이땐 남은 공간이 많음에도 불구하고 더이상 enqueue를 할 수 없습니다.
> 
> 이해를 돕기 위해 다음 사진을 첨부합니다.

![image](https://github.com/no1msh/Data-Structure-Study/assets/22425650/8165d973-dcbc-43e4-987e-8f52fe3b888a)

## Queue를 [ Array로 구현 vs LinkedList로 구현 ]

> 시간 복잡도 면에서 두 구현이 같으려면 `enqueue`, `dequeue`를 할때 이미 있는 원소들의 위치를 이동시키지 않고, `front`, `rear`와 같은 index를 저장하는 변수의 값을 바꾸는 방법을
> 사용해야 하는데 이것은 `dequeue`를 배열의 크기만큼 하면 더이상 데이터를 `enqueue`하지 못하므로 자료구조로써의 역할을 못하기 때문에 논외로 하겠습니다.

### 1. 시간복잡도 측면
> Array로 구현하게 되면 `dequeue`를 할 때 마다 첫 번째 원소를 삭제하고 나머지 원소들의 index를 한칸씩 옮겨줘야하기 때문에 `O(n)`의 시간 복잡도를 요구합니다.
>
> 반면 LinkedList는 `dequeue`를 하더라도 `front`에 위치한 노드를 삭제하고 그 다음 노드를 front에 지정해주면 되어서 `O(1)`의 시간 복잡도를 가집니다.
>
> **LinkedList 승!**

### 2. 공간효율성 측면
> Array로 구현 하면 배열의 크기는 고정적으로 가지므로 크기를 넘어서 데이터를 가지고 싶다면 새로운 크기의 배열에 복사해야합니다.
> 반면 LinkedList는 동적으로 크기 조절이 가능하지만 노드마다 다음 노드를 가리켜야하기 때문에 메모리의 오버헤드가 있습니다.
>
> **Array 승!**
